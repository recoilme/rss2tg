package rss2tg

import (
	"bufio"
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"os"
	"strings"
	"time"

	"github.com/PuerkitoBio/goquery"
	"github.com/SlyMarbo/rss"
)

func init() {
	http.DefaultTransport.(*http.Transport).ResponseHeaderTimeout = time.Duration(time.Second * 10)
}

// RssList return array links on rss
// or error if link nor parcelable
func RssList(path string) ([]string, error) {
	file, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	var lines []string
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		txt := strings.TrimSpace(scanner.Text())
		if !strings.HasPrefix(txt, "http") {
			txt = "http://" + txt
		}
		u, err := url.ParseRequestURI(txt)
		if err != nil {
			return lines, err
		}
		lines = append(lines, u.String())
	}
	return lines, scanner.Err()
}

// WordsList return lowercase words
func WordsList(path string) ([]string, error) {
	file, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	var lines []string
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		txt := strings.ToLower(strings.TrimSpace(scanner.Text()))
		if txt == "" {
			continue
		}
		lines = append(lines, txt)
	}
	return lines, scanner.Err()
}

func FeedItems(u string, words []string) error {
	feed, err := rss.Fetch(u)
	if err != nil {
		return err
	}
	for _, i := range feed.Items {
		WordsCheck(i.Title+" "+i.Summary+" "+i.Content, words)
	}
	return nil
}

func WordsCheck(txt string, words []string) (intersect []string, err error) {
	doc, err := goquery.NewDocumentFromReader(strings.NewReader(txt))
	if err != nil {
		return
	}
	txt = strings.ToLower(doc.Text())
	fields := strings.Fields(txt)
	txt = strings.Join(fields, " ")
	for _, w := range words {
		if strings.Contains(w, " ") {
			// Ad Tech
			if strings.Contains(txt, w) {
				intersect = append(intersect, w)
			}
		} else {
			// adtech
			for _, f := range fields {
				if f == w {
					intersect = append(intersect, w)
					break
				}
			}
		}
	}
	return
}

func TgTextSend(botId, apiKey, chatId, text string) error {
	link := "https://api.telegram.org/bot{botId}:{apiKey}/sendMessage?chat_id={chatId}&text={text}&disable_web_page_preview=1&parse_mode=HTML"
	link = strings.Replace(link, "{botId}", botId, -1)
	link = strings.Replace(link, "{apiKey}", apiKey, -1)
	link = strings.Replace(link, "{chatId}", chatId, -1)
	link = strings.Replace(link, "{text}", url.QueryEscape(text), -1)

	resp, err := http.Get(link)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		b, err := ioutil.ReadAll(resp.Body)
		fmt.Println("err ", string(b), err, resp.StatusCode)
		if resp.StatusCode == 429 {
			//too many requests
			time.Sleep(1 * time.Minute)
		}
		return err
	}
	_, err = io.Copy(ioutil.Discard, resp.Body)
	time.Sleep(2 * time.Second)
	return err
}

// Generated by curl-to-Go: https://mholt.github.io/curl-to-go

// curl https://api.openai.com/v1/completions \
//   -H "Content-Type: application/json" \
//   -H "Authorization: Bearer $OPENAI_API_KEY" \
//   -d '{
//   "model": "text-davinci-003",
//   "prompt": "Summarize this for a second-grade student:\n\nJupiter is the fifth planet from the Sun and the largest in the Solar System. It is a gas giant with a mass one-thousandth that of the Sun, but two-and-a-half times that of all the other planets in the Solar System combined. Jupiter is one of the brightest objects visible to the naked eye in the night sky, and has been known to ancient civilizations since before recorded history. It is named after the Roman god Jupiter.[19] When viewed from Earth, Jupiter can be bright enough for its reflected light to cast visible shadows,[20] and is on average the third-brightest natural object in the night sky after the Moon and Venus.",
//   "temperature": 0.7,
//   "max_tokens": 64,
//   "top_p": 1.0,
//   "frequency_penalty": 0.0,
//   "presence_penalty": 0.0
// }'

type OpenAIReq struct {
	Model            string  `json:"model"`
	Prompt           string  `json:"prompt"`
	Temperature      float64 `json:"temperature"`
	MaxTokens        int     `json:"max_tokens"`
	TopP             float64 `json:"top_p"`
	FrequencyPenalty float64 `json:"frequency_penalty"`
	PresencePenalty  float64 `json:"presence_penalty"`
}

type OpenAIResp struct {
	ID      string `json:"id"`
	Object  string `json:"object"`
	Created int    `json:"created"`
	Model   string `json:"model"`
	Choices []struct {
		Text         string      `json:"text"`
		Index        int         `json:"index"`
		Logprobs     interface{} `json:"logprobs"`
		FinishReason string      `json:"finish_reason"`
	} `json:"choices"`
	Usage struct {
		PromptTokens     int `json:"prompt_tokens"`
		CompletionTokens int `json:"completion_tokens"`
		TotalTokens      int `json:"total_tokens"`
	} `json:"usage"`
}

func OpenAISum(token, text string) (string, error) {
	data := OpenAIReq{
		Model:            "text-davinci-003",
		Prompt:           "Summarize this in three or four simple sentences\n\n" + text,
		Temperature:      0.7,
		MaxTokens:        256,
		TopP:             1.0,
		FrequencyPenalty: 0.0,
		PresencePenalty:  0.0,
	}
	payloadBytes, err := json.Marshal(data)
	if err != nil {
		return "", err
	}
	body := bytes.NewReader(payloadBytes)

	req, err := http.NewRequest("POST", "https://api.openai.com/v1/completions", body)
	if err != nil {
		return "", err
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", os.ExpandEnv("Bearer "+token))

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()
	bin, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}
	respOpenAI := OpenAIResp{}
	err = json.Unmarshal(bin, &respOpenAI)
	if err != nil {
		return "", err
	}
	result := ""
	if len(respOpenAI.Choices) > 0 {
		result = respOpenAI.Choices[0].Text
		fmt.Print(respOpenAI)
	}
	return result, err
}
